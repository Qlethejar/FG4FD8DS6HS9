local buffs = {"Tap Damage", "Diamonds", "Coins", "Luck", "Pet Speed", "Pet Damage", "Magnet", "Drops"}
local map = workspace.Map

-- Define a trim function
local function trim(s)
    local digits, trimmed = s:match("^(%d*)%s*|%s*(.-)%s*$")
    
    if digits and trimmed then
        if digits == "" and trimmed == "" then
            -- Ignore empty names
            return nil
        end

        return trimmed
    else
        -- Ignore names that don't match the expected pattern
        return nil
    end
end

-- Check if the LocalPlayer is in the game and has a character
local player = game.Players.LocalPlayer
if player and player.Character then
    local character = player.Character

    -- Check if the character has a HumanoidRootPart
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart and humanoidRootPart:IsA("BasePart") then
        -- Iterate over children
        for _, child in pairs(map:GetChildren()) do
            if child:IsA("Folder") then
                local childName = trim(child.Name)

                if childName then
                    -- First Teleportation logic
                    local persistentChild = child:FindFirstChild("PERSISTENT")

                    if persistentChild and persistentChild:IsA("Model") then
                        local teleportChild = persistentChild:FindFirstChild("Teleport")

                        if teleportChild and teleportChild:IsA("BasePart") then
                            humanoidRootPart.CFrame = teleportChild.CFrame
                        else
                            print("Child missing 'Teleport' part:", child.Name)
                        end
                    else
                        print("Child missing 'PERSISTENT' model:", child.Name)
                    end

                    -- Wait for a flexible time before moving to the next child
                    task.wait(1)

                    -- Second Teleportation logic
                    local interactChild = child:FindFirstChild("INTERACT")

                    if interactChild and interactChild:IsA("Model") then
                        -- Wait for "Upgrades" to appear
                        task.wait(1)

                        local upgradesChild = interactChild:FindFirstChild("Upgrades")

                        if upgradesChild and upgradesChild:IsA("Folder") then
                            -- Find the randomly named model inside "Upgrades"
                            local randomModel = upgradesChild:GetChildren()[1]

                            if randomModel and randomModel:IsA("Model") then
                                -- Find the "Center" part inside the random model
                                local centerChild = randomModel:FindFirstChild("Center")

                                if centerChild and centerChild:IsA("Part") then
                                    humanoidRootPart.CFrame = centerChild.CFrame
                                else
                                    print("Child missing 'Center' part in random model:", child.Name)
                                end
                            else
                                print("No randomly named model inside 'Upgrades':", child.Name)
                            end
                        else
                            print("Child missing 'Upgrades' folder:", child.Name)
                        end
                    else
                        print("Child missing 'INTERACT' model:", child.Name)
                    end

                    -- Wait for 1 second before moving to the next child
                    task.wait(1)

                    -- Upgrades_Purchase logic
                    for _, buff in pairs(buffs) do
                        local args = {
                            [1] = buff,
                            [2] = childName
                        }

                        game:GetService("ReplicatedStorage").Network.Upgrades_Purchase:InvokeServer(unpack(args))
                    end

                    task.wait(1)
                -- If trim returns nil, skip processing for this child
                elseif childName == nil then
                    print("Ignoring:", child.Name)
                else
                    print("Invalid child name format:", child.Name)
                end
            else
                print("Unsupported child type:", child:GetFullName())
            end
        end
    else
        print("Character missing 'HumanoidRootPart'")
    end
else
    print("LocalPlayer or character not found.")
end
